### 简单工厂模式
主要用于创建同一类对象的两种简单工厂模式
```js
  // 1
  function Book(name, price) {
    let o = Object.create(null)
    o.name = name
    o.price = price

    o.getName = function() {
      return this.name
    }

    return o
  }

  function Cup() {
    // ...
  }

  // 2
  function Factory(type, name, price) {
    switch(type) {
      case 'book':
        return new Book(name, price)
      case 'cup':
        return new Cup()
    }
  }
```

### 工厂方法模式
用于创建一类对象的多类实例
```js
  function Factory(type, ...args) {
    if (this instanceof Factory) {
      var s = new this[type](content)
      return s
    } else {
      return new Factory(type, content)
    }
  }

  Factory.prototype = {
    A: function(content) {
      console.log(content)
    },

    B: function(content) {
      console.log(content)
    },
  }
```

### 抽象工厂模式
制定类的结构而不关心其具体实现
```js
  function Factory(SubClass, SupType) {
    function F() {}
    F.prototype = new Factory[SupType]()
    SubClass.prototype = new F()
    SubClass.constructor = SubClass
  }

  Factory.Car = function() {
    this.type = 'car'
  }
  Factory.Car.prototype = {
    getName: function() {
      throw new Error('需子类定义')
    },
    getPrice: function() {
      throw new Error('需子类定义')
    }
  }

  function BMW(name, price) {
    this.name = name
    this.price = price
  }

  Factory(BMW, 'Car')

  BMW.prototype.getName = function() {
    console.log(this.name)
  }

  var bmw = new BMW('宝马', 1000)
```

### 建造者模式
将对象的构造层与表示层分离，使不同的构造过程可以采用不同的表示。工厂模式更关注最终构建的结果(对象)，建造者模式同时也关心构造过程。
```js
  function Human(params) {
    this,skill = params && params.skill || 'xx'
    this,hobby = params && params.hobby || 'xx'
  }

  Human.prototype = {
    getSkill: function() {
      return this.skill
    },
    getHobby: function() {
      return this.hobby
    }
  }

  function Named(name) {
    (function(name, that) {
      that.wholeName = name
      that.firstName = name.slice(0, name.indexOf(' '))
      that.lastName = name.slice(name.indexOf(' '))
    })(name, this)
  }

  function Work(work) {
    (function(work, that) {
      switch(work) {
        case 'code':
          that.work = '工程师'
          break
        case 'ui':
          that.work = '设计师'
          break
      }
    })(work, this)
  }

  Work.prototype.changeWork = function(work) {
    this.work = work
  }

  function Person(name, work) {
    var _person = new Human()
    _person.name = new Named(name)
    _person.work = new Work(work)
    return _person
  }

  var person = new Person('John Lion', 'code')
```
